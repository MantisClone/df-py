#!/usr/bin/env python

import brownie
from enforce_typing import enforce_types
import os
import sys

from util import blockrange, blocktime, calcrewards, csvs, dispense, getrate, \
    query
from util.constants import BROWNIE_PROJECT as B
from util.base18 import toBase18, fromBase18
from util.graphutil import oceanSubgraphUrl
from util.oceanutil import recordDeployedContracts, OCEANtoken

NETWORKS = ['development', 'eth_mainnet'] #development = ganache

# ========================================================================
HELP = """Data Farming tool, for use by OPF.

OPF steps:
1. query - run per NETWORK (Eth, Poly)
2. getrate - run per basetoken (OCEAN, H2O)
3. calc - per reward token (OCEAN, EWT)
4. dispense - per reward token

Then LP steps:
5. call Airdrop.claim() or claimFor(LP addr)

Usage: dftool query|getrate|calc|dispense|..

  dftool query NETWORK ST FIN NSAMP CSV_DIR - query chain, get stakes & vols
  dftool getrate TOKEN ST FIN CSV_DIR - get exchange rate
  dftool calc CSV_DIR TOT_OCEAN - from stakes/vols/rates, calc rewards
  dftool dispense CSV_DIR NETWORK [AIRDROP_ADDR] [TOKEN_ADDR] - from rewards, airdrop funds

  dftool compile - compile contracts
  dftool manyrandom - deploy many random tokens & pools then consume (for testing)
  dftool newairdrop NETWORK - deploy new airdrop contract
  dftool mine BLOCKS [TIMEDELTA] - force chain to pass time (ganache only)
  dftool newacct - generate new account
  dftool newtoken NETWORK - generate new token (for testing)

  dftool acctinfo NETWORK ACCOUNT_ADDR [TOKEN_ADDR] - info about an account
  dftool chaininfo NETWORK - info about a network
  dftool help - this message

Transactions are signed with envvar 'DFTOOL_KEY`.
"""
@enforce_types
def do_help():
    print(HELP)
    sys.exit(0)


# ========================================================================
@enforce_types
def do_query():
    HELP = f"""Query chain, output stakes & vols csvs

Usage: dftool query NETWORK ST FIN NSAMP CSV_DIR
  NETWORK -- one of {NETWORKS}
  ST -- first block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM
  FIN -- last block # to calc on | YYYY-MM-DD | YYYY-MM-DD_HH:MM | latest
  NSAMP -- # blocks to sample liquidity from, from blocks [ST, ST+1, .., FIN]
  CSV_DIR -- output dir for stakes-NETWORK.csv and pool_vols-NETWORK.csv

Uses these envvars:
ADDRESS_FILE -- e.g. for barge: ~/.ocean/ocean-contracts/artifacts/address.json
SUBGRAPH_URI -- e.g. for barge: http://127.0.0.1:9000
"""
    if len(sys.argv) not in [2+5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "query"
    NETWORK = sys.argv[2]
    ST, FIN, NSAMP = sys.argv[3], sys.argv[4], int(sys.argv[5])
    CSV_DIR = sys.argv[6]
    print(f"Arguments:\n NETWORK={NETWORK}" \
          f"\n ST={ST}\n FIN={FIN}\n NSAMP={NSAMP}" \
          f"\n CSV_DIR={CSV_DIR}")

    # extract envvars
    ADDRESS_FILE = os.environ.get('ADDRESS_FILE')
    SUBGRAPH_URI = os.environ.get('SUBGRAPH_URI')
    print(f"Envvars:\n ADDRESS_FILE={ADDRESS_FILE}\n " \
          f"SUBGRAPH_URI={SUBGRAPH_URI}")
    if ADDRESS_FILE is None:
        print("\nNeed to set envvar ADDRESS_FILE. Exiting."); sys.exit(0)
    if SUBGRAPH_URI is None:
        print("\nNeed to set envvar SUBGRAPH_URI. Exiting."); sys.exit(0)

    # shouldn't already have the output files
    c1 = csvs.stakesCsvFilename(CSV_DIR, NETWORK)
    if os.path.exists(c1):
        print(f"\nFile {c1} exists. Exiting."); sys.exit(0)
    c2 = csvs.poolVolsCsvFilename(CSV_DIR, NETWORK)
    if os.path.exists(c2):
        print(f"\nFile {c2} exists. Exiting."); sys.exit(0)

    # make directory if needed
    if not os.path.exists(CSV_DIR):
        print(f"Directory {CSV_DIR} did not exist, so created it")
        os.mkdir(CSV_DIR)

    #brownie setup
    brownie.network.connect(NETWORK)
    chain = brownie.network.chain

    if '-' in ST:
        st_block = blocktime.timestrToBlock(chain, ST)
    else:
        st_block = int(ST)

    if FIN == 'latest':
        fin_block = len(chain)
    elif '-' in FIN:
        fin_block = blocktime.timestrToBlock(chain, FIN)
    else:
        fin_block = int(FIN)

    #main work
    recordDeployedContracts(ADDRESS_FILE, NETWORK)
    seed = fin_block
    rng = blockrange.BlockRange(st_block, fin_block, NSAMP, seed)
    url = oceanSubgraphUrl(SUBGRAPH_URI)
    (stakes, pool_vols) = query.query(rng, url)
    csvs.saveStakesCsv(stakes, CSV_DIR, NETWORK)
    csvs.savePoolVolsCsv(pool_vols, CSV_DIR, NETWORK)

    print(f"dftool query: Done.")


# ========================================================================
@enforce_types
def do_getrate():
    HELP = f"""Get exchange rate, and output rate csv.

Usage: dftool getrate TOKEN ST FIN CSV_DIR
  TOKEN -- e.g. OCEAN, H2O
  ST -- start time -- YYYY-MM-DD
  FIN -- end time -- YYYY-MM-DD
  CSV_DIR -- output directory for rate-TOKEN.csv file
"""
    if len(sys.argv) not in [2+4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "getrate"
    TOKEN = sys.argv[2]
    ST, FIN = sys.argv[3], sys.argv[4]
    CSV_DIR = sys.argv[5]
    print(f"Arguments: ST={ST}, FIN={FIN}, CSV_DIR={CSV_DIR}")

    # shouldn't already have the output file
    c1 = csvs.rateCsvFilename(TOKEN, CSV_DIR)
    if os.path.exists(c1):
        print(f"\nFile {c1} exists. Exiting."); sys.exit(0)

    # make directory if needed
    if not os.path.exists(CSV_DIR):
        print(f"Directory {CSV_DIR} did not exist, so created it")
        os.mkdir(CSV_DIR)

    #main work
    rate = getrate.getrate(TOKEN, ST, FIN)
    print(f"rate = ${rate:.4f} / {TOKEN}")
    csvs.saveRateCsv(TOKEN, rate, CSV_DIR)

# ========================================================================
@enforce_types
def do_calc():
    HELP = f"""From stakes/vols/rates csvs, output rewards csv.

Usage: dftool calc CSV_DIR TOT_OCEAN
  CSV_DIR -- directory: input stakes & volumes csvs, output rewards.csv
  TOT_OCEAN -- total amount of OCEAN to distribute (in decimal, not wei)

Outputs
"""

    if len(sys.argv) not in [2+2]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "calc"
    CSV_DIR = sys.argv[2]
    TOT_OCEAN = float(sys.argv[3])
    print(f"Arguments:\n TOT_OCEAN={TOT_OCEAN}, CSV_DIR={CSV_DIR}")

    # do we have the input files?
    if not csvs.stakesCsvFilenames(CSV_DIR):
        print(f"\nNo 'stakes*.csv' files in '{CSV_DIR}'. Exiting."); sys.exit(0)
    if not csvs.poolVolsCsvFilenames(CSV_DIR):
        print(f"\nNo 'pool_vol*.csv' files in '{CSV_DIR}'. Exiting."); sys.exit(0)
    if not csvs.rateCsvFilenames(CSV_DIR):
        print(f"\nNo 'rate*.csv' files in '{CSV_DIR}'. Exiting."); sys.exit(0)

    # shouldn't already have the output file
    c = csvs.rewardsCsvFilename(CSV_DIR)
    if os.path.exists(c):
        print(f"\nFile {c} exists. Exiting."); sys.exit(0)

    #main work
    stakes = csvs.loadStakesCsvs(CSV_DIR)
    pool_vols = csvs.loadPoolVolsCsvs(CSV_DIR)
    rates = csvs.loadRateCsvs(CSV_DIR)
    rewards = calcrewards.calcRewards(stakes, pool_vols, rates, TOT_OCEAN)
    csvs.saveRewardsCsv(rewards, CSV_DIR)

    print(f"dftool calc: Done.")


# ========================================================================
@enforce_types
def do_dispense():
    HELP = f"""From rewards csv, airdrop funds to chain.

Usage: dftool dispense CSV_DIR NETWORK [AIRDROP_ADDR] [TOKEN_ADDR]
  CSV_DIR -- input directory for csv rewards file
  NETWORK -- one of {NETWORKS}. Airdrop contract's network
  AIRDROP_ADDR -- airdrop contract's address. If not given, uses envvar AIRDROP_ADDR

Transactions are signed with envvar 'DFTOOL_KEY`.
"""
    if len(sys.argv) not in [4, 5, 6]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "dispense"
    CSV_DIR = sys.argv[2]
    NETWORK = sys.argv[3]
    if len(sys.argv) == 4:
        print("Set AIRDROP_ADDR from envvar")
        AIRDROP_ADDR = os.getenv('AIRDROP_ADDR')
    else:
        AIRDROP_ADDR = sys.argv[4]

    if len(sys.argv) == 5:
        print("Set AIRDROP_ADDR from envvar")
        TOKEN_ADDR = os.getenv('AIRDROP_ADDR')
    else:
        TOKEN_ADDR = sys.argv[5]
    assert TOKEN_ADDR is not None

    # FIX - Look at dispense.dispense() for further details
    # TOKEN_ADDR = TOKEN_ADDR.split(",")


    print(f"Arguments: CSV_DIR={CSV_DIR}, NETWORK={NETWORK}" \
          f", AIRDROP_ADDR={AIRDROP_ADDR}")
    assert AIRDROP_ADDR is not None

    #main work
    brownie.network.connect(NETWORK)
    from_account = _getPrivateAccount()
    rewards = csvs.loadRewardsCsv(CSV_DIR)
    dispense.dispense(rewards, AIRDROP_ADDR, from_account,token_address=TOKEN_ADDR)

    print("dftool dispense: Done.")


# ========================================================================
@enforce_types
def do_newairdrop():
    HELP = f"""Deploy new airdrop contract.

Usage: dftool newairdrop NETWORK TOKEN_ADDR
  NETWORK -- one of {NETWORKS}
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "newairdrop"
    NETWORK = sys.argv[2]

    print(f"Arguments: NETWORK={NETWORK}")

    #main work
    brownie.network.connect(NETWORK)
    from_account = _getPrivateAccount()
    airdrop = B.Airdrop.deploy({"from": from_account})
    print(f"New airdrop contract deployed at address: {airdrop.address}")

    print("dftool newairdrop: Done.")


# ========================================================================
@enforce_types
def do_compile():
    HELP = f"""Compile contracts

Usage: dftool compile
"""
    if len(sys.argv) not in [2]:
        print(HELP)
        sys.exit(0)

    os.system("brownie compile")

# ========================================================================
@enforce_types
def do_manyrandom():
    HELP = f"""Deploy many random tokens & pools then consume (for testing)

Usage: dftool manyrandom
"""
    if len(sys.argv) not in [2]:
        print(HELP)
        sys.exit(0)

    from util.test import conftest
    recordDeployedContracts(conftest._ADDRESS_FILE, "development")
    conftest.fillAccountsWithOCEAN()
    num_pools = 10 #magic number
    conftest.randomDeployTokensAndPoolsThenConsume(num_pools)

    os.system("brownie compile")


# ========================================================================
@enforce_types
def do_mine():
    HELP = f"""Force chain to pass time (ganache only).

Usage: dftool mine BLOCKS [TIMEDELTA]
  BLOCKS -- e.g. 3
  TIMEDELTA -- e.g. 100
"""
    if len(sys.argv) not in [3,4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "mine"
    BLOCKS = int(sys.argv[2])
    if len(sys.argv) == 4:
        TIMEDELTA = int(sys.argv[3])
    else:
        TIMEDELTA = None

    print(f"Arguments: BLOCKS={BLOCKS}, TIMEDELTA={TIMEDELTA}")

    #main work
    NETWORK = 'development' #hardcoded bc it's the only one we can force
    brownie.network.connect(NETWORK)
    chain = brownie.network.chain
    if TIMEDELTA is None:
        chain.mine(blocks=BLOCKS, timedelta=TIMEDELTA)
    else:
        chain.mine(blocks=BLOCKS)

    print("dftool mine: Done.")

# ========================================================================
@enforce_types
def do_newacct():
    HELP = f"""Generate new account.

Usage: dftool newacct
"""
    if len(sys.argv) not in [2]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "newacct"

    #main work
    NETWORK = 'development' #hardcoded bc it's the only one we can force
    brownie.network.connect(NETWORK)
    account = brownie.network.accounts.add()
    print("Generated new account:")
    print(f" private_key = {account.private_key}")
    print(f" address = {account.address}")
    print(f" For other dftools: export DFTOOL_KEY={account.private_key}")

# ========================================================================
@enforce_types
def do_newtoken():
    HELP = f"""Generate new token (for testing).

Usage: dftool newtoken NETWORK
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "newtoken"
    NETWORK = sys.argv[2]
    print(f"Arguments:\n NETWORK={NETWORK}")

    #main work
    brownie.network.connect(NETWORK)
    from_account = _getPrivateAccount()
    token = B.Simpletoken.deploy(
        "TST", "Test Token", 18, 1e21, {"from": from_account})
    print(f"Token '{token.symbol()}' deployed at address: {token.address}")

# ========================================================================
@enforce_types
def do_acctinfo():
    HELP = f"""Info about an account.

Usage: dftool acctinfo NETWORK ACCOUNT_ADDR [TOKEN_ADDR]
  NETWORK -- one of {NETWORKS}
  ACCOUNT_ADDR -- e.g. '0x987...' or '4'. If the latter, uses accounts[i]
  TOKEN_ADDR -- e.g. '0x123..'

If envvar ADDRESS_FILE is not None, it gives balance for OCEAN token too.
"""
    if len(sys.argv) not in [4,5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "acctinfo"
    NETWORK = sys.argv[2]
    ACCOUNT_ADDR = sys.argv[3]
    TOKEN_ADDR = sys.argv[4] if len(sys.argv) >= 5 else None

    # do work
    print("Account info:")
    brownie.network.connect(NETWORK)
    if len(str(ACCOUNT_ADDR)) == 1:
        addr_i = int(ACCOUNT_ADDR)
        ACCOUNT_ADDR = brownie.accounts[addr_i]
    print(f"  Address = {ACCOUNT_ADDR}")

    if TOKEN_ADDR is not None:
        token = B.Simpletoken.at(TOKEN_ADDR)
        balance = token.balanceOf(ACCOUNT_ADDR)
        print(f"  {fromBase18(balance)} {token.symbol()}")

    #Give balance for OCEAN token too.
    ADDRESS_FILE = os.environ.get('ADDRESS_FILE')
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE, NETWORK)
        OCEAN = OCEANtoken()
        if OCEAN.address != TOKEN_ADDR:
            print(f"  {fromBase18(OCEAN.balanceOf(ACCOUNT_ADDR))} OCEAN")

# ========================================================================
@enforce_types
def do_chaininfo():
    HELP = f"""Info about a network.

Usage: dftool chaininfo NETWORK
  NETWORK -- one of {NETWORKS}
"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "chaininfo"
    NETWORK = sys.argv[2]

    #do work
    brownie.network.connect(NETWORK)
    blocks = len(brownie.network.chain)
    print("\nChain info:")
    print(f"  # blocks: {len(brownie.network.chain)}")

# ========================================================================
@enforce_types
def _getPrivateAccount():
    private_key = os.getenv('DFTOOL_KEY')
    assert private_key is not None, "Need to set envvar DFTOOL_KEY"
    account = brownie.network.accounts.add(private_key=private_key)
    print(f"For private key DFTOOL_KEY, address is: {account.address}")
    return account

# ========================================================================
# main
@enforce_types
def do_main():
    if len(sys.argv) == 1 or sys.argv[1] == "help":
        do_help()

    #write actions
    elif sys.argv[1] == "query":
        do_query()
    elif sys.argv[1] == "getrate":
        do_getrate()
    elif sys.argv[1] == "calc":
        do_calc()
    elif sys.argv[1] == "dispense":
        do_dispense()

    elif sys.argv[1] == "compile":
        do_compile()
    elif sys.argv[1] == "manyrandom":
        do_manyrandom()
    elif sys.argv[1] == "newairdrop":
        do_newairdrop()
    elif sys.argv[1] == "mine":
        do_mine()
    elif sys.argv[1] == "newacct":
        do_newacct()
    elif sys.argv[1] == "newtoken":
        do_newtoken()

    #read actions
    elif sys.argv[1] == "acctinfo":
        do_acctinfo()
    elif sys.argv[1] == "chaininfo":
        do_chaininfo()
    else:
        do_help()

if __name__ == "__main__":
    do_main()
